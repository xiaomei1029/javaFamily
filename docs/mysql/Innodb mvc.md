# MVCC的目标是解决多个事务同时访问一条记录时出现的数据不一致问题。
InnoDB的MVCC（Multi-Version Concurrency Control）机制解决了并发事务中读取和写入操作之间的冲突问题，主要包括以下两个方面：

避免了读取操作被写入操作阻塞：在传统的锁定机制下，当一个事务正在更新或插入某一条记录时，其他事务要读取该记录就必须等待写入操作完成。而使用MVCC机制后，读取操作可以同时进行，不会被写入操作所阻塞。这样可以提高并发性能。

保障了读取操作的一致性视图：在MVCC中，每个事务都有自己的一致性读取视图，用于确定对其可见的数据。当一个事务开始时，它会创建一个读取视图，该视图标识了在该事务启动之前已经提交的所有事务。这样，在读取时，事务只能看到在其启动时间点之前已经提交的数据，避免了脏读和不可重复读等问题。

现在，让我们来看一个具体的例子来说明MVCC机制在更新或插入同一条记录时的工作原理：

假设有两个事务，事务A和事务B，它们同时对同一条记录进行更新或插入。

开始时，事务A启动，并创建一个读取视图，标识了在事务A启动之前已经提交的所有事务。

同时，事务B也启动，并创建自己的读取视图，标识了在事务B启动之前已经提交的所有事务。

假设事务A先执行更新或插入操作，并将新的数据写入数据库。这个时候，由于事务A的更新在事务B启动之前完成，所以事务B的读取视图不会包含事务A的更新。

然后，事务B执行查询操作，尝试读取该记录。因为事务B的读取视图不包含事务A的更新，所以事务B将看到之前的数据版本，而不是事务A更新后的数据。这样保证了事务B的读取操作与事务A的写入操作相互独立，不会相互干扰。

通过MVCC机制，事务A和事务B可以同时进行读取和写入操作，不会相互阻塞，并且每个事务都能看到符合自己读取视图的一致性数据，保证了事务的隔离性和一致性。

#下面解释为何Innodb 的读视图会产生幻读问题。

快照读的读取视图主要用来记录事务开始时数据库中的数据版本，以提供事务一致性的读取视图。在这个读取视图中，通常会存储以下信息：

事务开始时间戳：记录当前事务开始的时间戳或序列号，用于标识当前读取视图的创建时间，以及与其他事务的时间顺序关系。

已经存在的数据行版本信息：记录事务开始时已经存在的数据行的版本信息，包括数据行的标识符（如行号或键值）、数据内容的版本号或时间戳等。这些信息用于标识事务开始时数据库中的数据版本。

事务自身的标识符：记录当前事务的标识符或ID，以便数据库系统能够识别和管理当前事务的读取视图。

通过存储这些信息，快照读的读取视图可以帮助事务在整个查询过程中都能看到一致的数据版本，同时也能避免读取到其他事务后续修改或删除的数据行。这种设计可以提供事务的隔离性和一致性，并确保并发执行的事务不会相互干扰

# 快照读的过程
快照读是数据库系统中一种常见的并发控制技术，用于提供事务的一致性读取视图。以下是快照读的过程，并通过这个过程来解释为什么其他事务插入的行是可见的：

事务开始：当一个事务开始时，它将创建一个快照读的读取视图。这个读取视图会记录当前事务开始时数据库中的数据版本。

查询数据：在进行查询操作时，事务会根据自己创建的读取视图来读取数据。这意味着事务只能看到在自己开始时已经存在的数据版本，而不会看到其他事务后续修改或删除的数据。

其他事务插入数据：如果在当前事务开始后，有其他事务插入新的数据行，这些新插入的行属于新的数据版本，不在当前事务的读取视图范围内。

读取可见性：由于快照读提供的是事务开始时的一致性读取视图，因此对于其他事务插入的新行，它们在当前事务开始时并不存在，所以这些新插入的行对当前事务是可见的。

因此，通过快照读的过程，我们可以看到其他事务插入的新行是可见的。这是因为快照读的设计初衷是为了提供事务开始时的一致性读取视图，使得事务在整个查询过程中都能看到一致的数据版本。对于其他事务插入的新行，它们属于新的数据版本，在事务开始时并不存在于当前事务的读取视图中，因此对当前事务是可见的。

# innodb 的next-key-lock 锁解决了RR可重复读的幻读问题

https://tech.meituan.com/2014/08/20/innodb-lock.html 