# java基础
https://mp.weixin.qq.com/s/-xFSHf7Gz3FUcafTJUIGWQ
## synchronized
- synchronized 关键字的产生是为了解决多线程并发访问共享资源时可能出现的数据不一致性和并发访问冲突的问题。在多线程环境下，如果多个线程同时访问和修改共享资源，可能会导致数据的不确定性、错乱或者数据损坏。

- synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，
  他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。
- 执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。
  执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。

- synchronized 关键字可以用来实现同步锁，在Java中，每个对象都有一个内置的锁（也称为监视器锁或互斥锁），当一个线程获取到这个对象的锁时，其他线程就无法同时获取该对象的锁，从而保证了对共享资源的原子性操作。

- 为什么说synchronized是一种重量级锁
  在Java中，synchronized是一种重量级锁的说法源于其实现机制。在早期的Java版本中，每个对象都有一个监视器（monitor）与之关联，这个监视器实际上就是一个互斥锁。当一个线程进入synchronized代码块时，它会尝试获取对象的监视器，如果该监视器已经被其他线程占用，那么线程就会被阻塞，直到获取到监视器为止。

重量级锁之所以称为“重量级”，是因为它涉及到操作系统层面的线程调度和切换。当一个线程被阻塞时，操作系统会将其挂起并切换到内核态，这涉及到用户态和内核态之间的切换，需要消耗较多的系统资源和时间。此外，重量级锁还涉及到线程的上下文切换和调度，这些操作也会增加锁的获取和释放的开销。

随着Java虚拟机的不断发展和优化，现代的JVM在处理synchronized锁时已经做了很多优化，例如引入了偏向锁、轻量级锁和自旋锁等机制，以减少锁的竞争和提高性能。因此，虽然Synchronized锁在早期被称为重量级锁，但在现代JVM中，其性能已经得到了很大的改善，并不是绝对意义上的“重量级锁”了。

总的来说，现代JVM对synchronized锁进行了优化，使其在大部分情况下具有较高的性能和效率。虽然曾经被称为重量级锁，但随着技术的发展和优化，其性能已经得到了很大的提升。

- 为什么 线程被阻塞时，操作系统会将其挂起并切换到内核态
  当一个线程被阻塞时，操作系统会将其挂起并切换到内核态的主要原因是为了进行线程的管理和调度。在操作系统中，有两种运行模式：用户态和内核态。

用户态：线程在用户态下执行时，只能访问受限的资源和执行受限的指令，不能直接访问操作系统的资源。这样可以保证线程之间的安全性和隔离性，防止恶意程序对系统造成破坏。但是在用户态下，线程无法直接进行一些需要操作系统权限的操作，比如访问硬件设备、进行系统调用等。

内核态：线程在内核态下执行时，可以访问系统的所有资源和执行所有指令，具有更高的权限和功能。当一个线程需要进行一些需要操作系统支持的操作时，比如进行系统调用、申请内存等，就需要切换到内核态下执行。

当一个线程被阻塞时，通常是由于需要等待某种事件的发生，比如I/O操作完成、锁的释放等。这时操作系统会将该线程挂起，并切换到内核态去处理这个事件。在内核态下，操作系统可以更好地管理线程的状态、资源分配和调度，以便及时响应事件的发生。

总之，当一个线程被阻塞时，操作系统将其挂起并切换到内核态，主要是为了进行线程的管理和调度，以便有效地处理各种事件和保证系统的正常运行。